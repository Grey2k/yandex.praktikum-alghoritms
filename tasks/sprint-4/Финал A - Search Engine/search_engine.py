"""
-- ПРИНЦИП РАБОТЫ --
Если масив был сдвинут то дополнительно для использования бинарного поиска нам нужно
организоавть проверку на нахождение отсортированной половины массива, сравнив левый конец с медианой
Далее воспользуемся обычным бинарным поиском

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
По условию задачи мы имеем дело с массивом с уникальными элементами, остальные случаи проверены написанными юнит-тестами

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
при каждой итерации мы сокращаем интервал поиска в два раза, соответственно сложность будет O(logN)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы храним искомый массив + дополнительные счетчики + используем рекурсивный алгоритм, из-за этого сложность O(logN)
Так как мы делаем O(logN) вызовов в худшем случае и храним на стеке значения каждого вызова,
в python не используется оптимизация хвостовой рекурсии (TCO)

-- ID успешной посылки --
49458142
"""
import sys


def main():
    n = int(input())

    documents = []
    for _ in range(n):
        documents.append(sys.stdin.readline().strip().split())

    q = int(input())

    queries = []
    for _ in range(q):
        queries.append(sys.stdin.readline().strip().split())

    for query in queries:
        docs = search_engine(query)

        if len(docs) > 0:
            print(' '.join(map(str, docs)))


def search_engine(query):
    return [1, 2, 3]


if __name__ == '__main__':
    main()
