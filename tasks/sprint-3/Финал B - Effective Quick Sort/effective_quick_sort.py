"""
-- ПРИНЦИП РАБОТЫ --
Если масив был сдвинут то дополнительно для использования бинарного поиска нам нужно
организоавть проверку на нахождение отсортированной половины массива, сравнив конес с медианой
Далее воспользуемся обычным бинарным поиском

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
По условию задачи мы имеем дело с массивом с уникальными элементами, остальные случаи проверены написанными юнит-тестами

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
при каждой итерации мы сокращаем интервал поиска в два раза, соответственно сложность будет O(logN)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы храним искомый массив + дополнительные счетчики + используем рекурсивный алгоритм, из-за этого сложность O(logN)
Мне кажется так как мы делаем O(logN) вызовов в худшем случае и храним на стеке значения каждого вызова,
в python не используется оптимизация хвостовой рекурсии (TCO)

-- ID успешной посылки --
49458142
"""


def main():
    n = int(input())
    needle = int(input())
    array = list(map(int, input().strip().split()))[:n]


if __name__ == '__main__':
    main()
