"""
-- ПРИНЦИП РАБОТЫ --
В данной задаче мы вычисляем матрицу расстояний Левенштейна для двух последовательностей
В кажестве базового случая мы берем длину самой последовательности и далее
с помощью динамического программирования мы сравниваем символы на предыдущих позициях, если они одинаковые - то берем
уже вычисленное расстояние, если нет - то мерем минимум + 1

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Можно доказать ММИ что Mn-1k-1 < Mnk + 1.
Так как у нас возрастающая двумерная поверхность - при докозательстве от противного
- Mn-1k-1 > Mnk + 1 - это противоречие

Так же решение проверено тестами

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Мы обходим массив размерностью N x M - соответственно сложность O(M*N),
где N - длина первой а M - длина второй последовательности

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы храним в памяти и заполняем значения в массиве M x N - сложность O(M*N),
где N - длина первой а M - длина второй последовательности

-- ID успешной посылки --
53221830
"""


def main():
    try:
        first = list(input().strip())
    except EOFError:
        first = ''

    n = len(first)

    try:
        second = list(input().strip())
    except EOFError:
        second = ''

    m = len(second)

    dp = [[i] + [0] * m for i in range(n + 1)]
    dp[0] = list(range(0, m + 1))

    if m != 0 and n != 0:
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if first[i - 1] == second[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1

        levenstein_distance = dp[n][m]
    else:
        levenstein_distance = max(n, m)

    print(levenstein_distance)


if __name__ == '__main__':
    main()
