"""
-- ПРИНЦИП РАБОТЫ --
Сперва мы проверяем общую сумму очков, если она нечетная - то значит разбиение не возможно.
Вторую часть задачи решаем формулируем так - нужно найти последовательность которая в сумму даст SUM/2
- где SUM - общая сумма всех очков, если такая последовательность найдена - то задача решена.
Будем решать задачу с помощью динамического программирования, постепенно увеличивая кол-во элементов
в последовательности и тестировать с предыдущими комбинациями

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Мы последовательно перебираем все пары, используя предыдущее значение для уже расчитанных пар,
соответственно если решения нет то его невозможно получить, так как все сравения произведены иначе - решение найдено

Так же решение проверено тестами

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Мы обходим массив размерностью SUM/2 - соответственно сложность O(N * SUM / 2),
где N - кол-во партий, SUM - общая сумма очков

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Для расчета мы храним массив размерностью SUM/2
- соответственно сложность O(SUM / 2), где SUM - общая сумма очков

-- ID успешной посылки --
53227564
"""


def main():
    n = int(input().strip())

    try:
        scores = sorted(map(int, input().split()))
    except EOFError:
        scores = []

    all_sum = sum(scores)

    if n == 0:
        possibility = True
    elif all_sum % 2 != 0:
        possibility = False
    else:
        half_sum = all_sum // 2

        dp = [False] * (half_sum + 1)

        for i in range(n):
            for j in range(half_sum, scores[i] - 1, -1):
                if dp[j - scores[i]] or (scores[i] == j):
                    dp[j] = True

        possibility = dp[half_sum]

    print(str(possibility))


if __name__ == '__main__':
    main()
